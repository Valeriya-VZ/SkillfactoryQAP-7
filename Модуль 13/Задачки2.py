# Программа, которая находит индекс последнего отрицательного элемента в списке
list_ = [-5, 2, 4, 8, 12, -7, 5]
index_negativ = None  # Объявим переменную, в которой будем хранить индексы

for i, value in enumerate(list_):
    if value < 0:
        print("Индекс элемента:", i)
        print("Значение элемента:", value)
        index_negativ = i  # Перезаписываем значение индекса
print("Конец цикла. Индекс последнего отрицательного элемента:", index_negativ)


# Проверить гипотезу Сиракуз
n = int(input("Введите натуральное число:\n"))
while True:
    if n % 2 == 0:
        n /= n
    else:
        n = ((n * 3 + 1) // 2)
    if n == 1:
        print(n)
        break

a = "foo"
b = "bar"

print(1 and a or b)

a = ""
b = "bar"

print(1 and a or b)

# Число целое в промежутке от 100 до 999 и делится на 2 и а 3
a = int(input("Введите целое число:\n"))
if type(a) == int:
    if 100 < a < 999:
        if a % 2 == 0:
            if a % 3 == 0:
                print("Число соответсует условию:", a)

# аналогичное решение с использованием логических операторов и сравнения
a = int(input("Введите целое число:\n"))
if type(a) == int and 100 < a < 999 and a % 2 == 0 and a % 3 == 0:
    print("Число соответсует условию:", a)

# Более питоновский подход с использованием функции all
a = int(input("Введите целое число:\n"))
if all([type(a) == int,
        100 < a < 999,
        a % 2 == 0,
        a % 3 == 0]):
    print("Число соответсует условию:", a)

# Напишите программу, которая на вход принимает последовательность целых чисел, и возвращает True,
# если все числа ненулевые, и False, если хотя бы одно число равно 0.
L = list(map(int, input("Введите числа через пробел:\n").split()))
print(all(L))

# Напишите программу, которая на вход принимает последовательность целых чисел и возвращает True,
# если все числа равны нулю, и False, если найдется хотя бы одно ненулевое число.
# Разрешается использование только логических операторов и функций all([ ]) и any([ ]).
L = list(map(int, input("Введите числа через пробел:\n").split()))
print(not any(L))

# При помощи генератора списков создайте таблицу умножения чисел от 1 до 10.
M = [[i*j for j in range(1, 11)] for i in range(1, 11)]
print(M)

# Интересный эффект образуется в сочетании использования генераторов списков и функции input().
# На каждой итерации цикла консоль будет запрашивать данные для ввода и сохранять их в качестве элемента списка.
L = [input() for i in range(5)]
# Приведенный выше пример 5 раз запросит у пользователя данные для входа и запишет их в список.
# Здесь же можно использовать сразу преобразование в необходимый тип, если он заранее известен.
LLL = [int(input()) for i in range(5)]
# Модифицируйте последний пример таким образом, чтобы в список сохранялось True,
# если элемент четный, и False, если элемент нечетный.
LL = [int(input()) % 2 == 0 for i in range(5)]
print(LL)
# А здесь использование all([ ]) и any([ ]), чтобы программа выводила True, если есть хотя бы одно четное число.
LLLL = [int(input()) % 2 == 0 for i in range(5)]
print(any(LLLL))
# как нужно записать логическое выражение, используя all([ ]) и any([ ]) над списком четности если его результат
# будет истинным тогда и только тогда, когда в списке есть хотя бы один четный и хотя бы один нечетный элемент
LLLLL = [int(input()) % 2 == 0 for i in range(5)]
print(any(LLLLL) and not all(LLLLL))

# Используя функцию zip() внутри генераторов списков, вычислите поэлементные произведения списков L и M.
N = [i for i in range(10)]
# 0 1 2 3 4 5 6 7 8 9
M = [i for i in range(10, 0, -1)]
# 10 9 8 7 6 5 4 3 2 1
for a, b in zip(N, M):
    print(a * b)
# Решение от курса:
K = [a*b for a,b in zip(N,M)]
print(K)
