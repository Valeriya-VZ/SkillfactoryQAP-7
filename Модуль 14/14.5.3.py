# a*x**2 + b*x + c = 0 - общий вид уравнения
# D = b**2 - 4*a*c - дискриминант
# Если D<0, то уравнение не имеет вещественных корней
# Если D=0, то уравнение имеет один корень - x = -b/(2*a)
# Если D>0, то уравнение имеет два корня
# x1 = (-b - D**0.5)/(2*a)
# x2 = (-b + D**0.5)/(2*a)
#
# P.S. D**0.5 - равносильно извлечению квадратного корня
#
# Напишите функцию D(a,b,c), возвращающую дискриминант квадратного уравнения.
def D(a,b,c):
    return b**2 - 4*a*c

# Реализуйте функцию quadratic_solve(a,b,c), возвращающую «Нет вещественных корней»
# в случае отрицательного дискриминанта.
def quadratic_solve(a,b,c):
    if D(a,b,c) < 0:
        return "Нет вещественных корней"
# Далее модифицируем функцию, чтобы при нулевом дискриминанте возвращалось значение единственного корня.
    elif D(a,b,c) == 0:
        return -b / (2 * a)
# и последним этапом если больше нуля нужно вернуть два значения:
    else:
        return (((-b) - D(a,b,c) ** 0.5) / (2 * a)), (((-b) + D(a,b,c) ** 0.5) / (2 * a))

print(D(1, 20, 2))  # 392
print(quadratic_solve(1, 20, 2))  # (-19.899494936611667, -0.10050506338833465)

# разбили строку из input и преобразовали к float
L = list(map(float, input("Введите значения через пробел:").split()))
# [1, 0, -1] - например
# Конечно, можно было бы присвоить новым переменным полученные значения,
# или передавать в аргументы функции, обращаясь через индексы.
print(quadratic_solve(L[0], L[1], L[2]))
# (-1.0, 1.0)
# Более питоновский вариант используя распаковку списка *
print(quadratic_solve(*L))
# Представим, что у нас теперь аргументы хранятся не в виде списка, а в виде словаря.
M = {'a' : 1,
     'b' : 0,
     'c' : -1}
# Тогда используем две ** для вывода значений
print(quadratic_solve(**M))